================================================================================
                    TEE + MPC PROTOCOL PROJECT GUIDE
                          Comprehensive Reference
================================================================================

## PROJECT OVERVIEW

This is a sophisticated TEE (Trusted Execution Environment) + MPC (Multi-Party Computation) protocol implementation that provides secure, verifiable TLS communications with redaction capabilities. The system uses split AEAD encryption to allow selective disclosure of sensitive data while maintaining cryptographic integrity.

## ARCHITECTURE OVERVIEW

### Core Components
- **TEE_K**: Key management and TLS proxy service (port 8080)
- **TEE_T**: Tag computation and verification service (port 8081) 
- **Client**: User application that makes redacted TLS requests
- **Proxy**: Optional TLS proxy for additional security
- **Shared**: Common types, session management, and utilities

### Protocol Flow (4 Phases)
1. **TLS Handshake**: TEE_K proxies TLS handshake with target server
2. **Split AEAD**: TEE_K and TEE_T cooperatively encrypt redacted requests
3. **Redaction**: Client sends redacted HTTP requests with commitment proofs
4. **Response Handling**: Split AEAD decryption of server responses

### Session Management
- Multi-client support with UUID-based session IDs
- Session state tracked across TEE_K and TEE_T
- WebSocket-based communication between all components

## CRITICAL MISTAKES TO AVOID

### 1. OVER-ENGINEERING FIXES ❌
**What I Did Wrong:**
- Deleted entire working files (messages.go) for minor issues
- Changed function signatures across the entire codebase  
- Forced architectural migrations when simple fixes were needed
- Broke working functionality while fixing unrelated issues

**What To Do Instead:**
- Make MINIMAL, SURGICAL changes
- Fix only the specific problematic code
- Preserve working functionality
- Test frequently during changes

### 2. JSON MARSHALING BUG ❌
**The Original Problem:**
```go
// ❌ WRONG - Causes base64 encoding
func CreateSessionMessage(msgType MessageType, sessionID string, data interface{}) (*Message, error) {
    dataBytes, err := json.Marshal(data)  // First marshal
    if err != nil {
        return nil, err
    }
    return &Message{
        Type: msgType,
        SessionID: sessionID,
        Data: json.RawMessage(dataBytes), // ❌ Second marshal = base64!
    }, nil
}
```

**The Correct Fix:**
```go
//  CORRECT - Direct assignment
func CreateSessionMessage(msgType MessageType, sessionID string, data interface{}) (*Message, error) {
    return &Message{
        Type: msgType,
        SessionID: sessionID,
        Data: data,        //  Direct assignment - no double marshaling!
        Timestamp: time.Now(),
    }, nil
}
```

### 3. FUNCTION SIGNATURE CHANGES ❌
**What I Did Wrong:**
- Changed `CreateMessage` from `(*Message, error)` to `*Message`
- Broke every single call site in the codebase
- Created cascading compilation errors

**What To Do Instead:**
- Keep existing function signatures when possible
- If changes are needed, update ALL call sites systematically
- Use grep to find all usage before making changes

## PROPER CHANGE METHODOLOGY

### 1. IDENTIFY THE EXACT PROBLEM
- Use grep/codebase search to find the specific problematic code
- Don't assume the problem is architectural
- Look for the minimal root cause

### 2. MAKE MINIMAL CHANGES
- Fix only the specific bug
- Don't refactor unrelated code
- Preserve existing working patterns

### 3. TEST INCREMENTALLY
- Build after each small change
- Test the demo frequently
- Revert immediately if something breaks

### 4. DOCUMENT CHANGES
- Explain why the change was necessary
- Document what was broken and how it was fixed

## CODE STRUCTURE PATTERNS

### Message System
- Each service (tee_k, tee_t, client) has its own messages.go
- Shared session management in shared/ package
- Message types use consistent naming (MsgXxxYyy)

### Session Management
- SessionID: UUID string for each client session
- SessionManager: Handles routing and lifecycle
- Session state: Tracks TLS, redaction, and response state

### WebSocket Communication
- All services communicate via WebSocket
- Messages include session IDs for routing
- Graceful error handling with proper connection cleanup

### Error Handling Patterns
```go
//  GOOD - Consistent error handling
if err != nil {
    log.Printf("[SERVICE] Operation failed: %v", err)
    t.sendErrorToSession(sessionID, fmt.Sprintf("Operation failed: %v", err))
    return
}
```

## PROTOCOL DETAILS

### TLS Handshake Phase
1. Client requests connection to target server
2. TEE_K establishes actual TLS connection
3. TEE_K sends handshake keys to Client for verification
4. Client validates certificate chain

### Split AEAD Encryption
1. TEE_K generates encryption parameters
2. TEE_T provides key share for split computation
3. Combined key used for AEAD encryption
4. Tag computation split between TEE_K and TEE_T

### Redaction System
- R_NS: Non-sensitive data (unchanged)
- R_S: Sensitive data (redacted, no proof)
- R_SP: Sensitive data with proof (redacted, commitment-based)
- XOR-based redaction maintains data length

### Response Handling
- Server responses processed with split AEAD
- Each TLS record verified independently
- Decryption streams generated by TEE_K
- Client reconstructs plaintext responses

## DEBUGGING APPROACHES

### Common Issues
1. **"No TCP connection available"** - Race condition in client
2. **"Invalid character 'e' looking for beginning of value"** - Base64 bug
3. **"0 processed records"** - Missing record headers in TEE_T
4. **Session ID mismatches** - Inconsistent session routing

### Debug Logging
- Enable detailed logging for message flow
- Check WebSocket connection states
- Verify session ID propagation
- Monitor TLS record processing

### Testing Strategy
- Use demo.sh for end-to-end testing
- Build individual components first
- Test with timeout to avoid hanging
- Check exit codes for success/failure

## FILE ORGANIZATION

```
/tee-mpc/
├── tee_k/
│   ├── tee_k.go          # Main TEE_K service
├── tee_t/
│   ├── tee_t.go          # Main TEE_T service
├── client/
│   ├── client.go         # Client implementation
├── shared/
│   ├── types.go          # Shared data structures
│   ├── session_manager.go # Session management
│   └── ...
├── minitls/              # Custom TLS implementation
├── demo.sh               # End-to-end demo script
└── build.sh              # Build script
```

## KEY CAVEATS

1. **Message Type Consistency**: Each service defines its own message types
2. **Session Management**: Shared infrastructure but local message handling
3. **WebSocket Lifecycle**: Proper cleanup prevents resource leaks
4. **TLS Record Processing**: Exact byte-level handling required
5. **Redaction Commitments**: Cryptographic proofs must be precise

## DEVELOPMENT WORKFLOW

### Making Changes
1. Identify the specific problem with grep/search
2. Make minimal changes to fix only that issue
3. Test with `./demo.sh` after each change
4. Document why the change was necessary

### Adding Features
1. Start with the protocol design
2. Implement in one service at a time
3. Add corresponding message types
4. Test incrementally
5. Update session management if needed

### Debugging Protocol Issues
1. Enable verbose logging in all services
2. Check message flow between services
3. Verify session ID propagation
4. Monitor TLS record boundaries
5. Test with known-good inputs

## WORKING DEMO

The demo.sh script provides a complete end-to-end test:
- Builds all services
- Starts TEE_K and TEE_T
- Runs client with redacted HTTP request
- Verifies split AEAD protocol completion
- Exit code 0 indicates success

## SUCCESS METRICS

A working system should show:
-  All services build without errors
-  Session creation and management
-  TLS handshake completion
-  Split AEAD encryption/decryption
-  Redaction verification
-  HTTP response reconstruction
-  Clean exit code 0

## FINAL NOTES

This is a complex cryptographic protocol implementation. Always:
- Make minimal changes
- Test frequently
- Preserve working functionality
- Document changes
- Ask for clarification before major modifications

The system is currently working correctly. Any changes should be made with extreme caution to avoid breaking the delicate protocol interactions.

================================================================================ 