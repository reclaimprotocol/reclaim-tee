TEE+MPC SYSTEM DEVELOPMENT CONTINUATION PROMPT

PROJECT OVERVIEW:
You are working on a TEE (Trusted Execution Environment) + MPC (Multi-Party Computation) protocol implementation for secure web request processing. The system consists of three components:
- TEE_K Service (port 8080): Handles TLS connections to target websites, performs split AEAD encryption
- TEE_T Service (port 8081): Performs redaction verification and decryption of response streams  
- Client: Orchestrates the protocol, connects to both TEEs via WebSocket

RECENT ACCOMPLISHMENTS:
1. RACE CONDITION RESOLVED: Fixed CLOSE_NOTIFY alert detection from ~10% to 100% success rate
2. PROTOCOL COMPLETION FIXED: Simplified completion logic from dual processing to unified approach
3. CODEBASE ANALYSIS COMPLETE: Identified multi-client limitations and resource leak vulnerabilities
4. TESTING VALIDATED: 100/100 test runs successful, race condition completely eliminated

KEY LESSON LEARNED:
When you suggested "Just read records till EOF, send them for split AEAD, wait for split AEAD to process them, finished" - this simple insight solved the race condition that I was trying to fix with complex timeout strategies and dual processing paths. The problem was architectural (conflicting completion logic), not timing-based. Always prefer simple solutions over complex technical workarounds.

CURRENT SYSTEM STATE:
- Protocol works perfectly for single clients (100% success rate)
- Race condition in CLOSE_NOTIFY detection completely resolved
- Clean completion tracking: recordsSent vs recordsProcessed + eofReached
- Code is stable and production-ready for single-client scenarios

CRITICAL LIMITATIONS IDENTIFIED:
1. SINGLE-CLIENT ONLY: Both TEE_K and TEE_T overwrite global state when multiple clients connect
2. RESOURCE LEAKS: Multiple goroutine, connection, memory, and crypto material leaks on failures
3. NO SESSION MANAGEMENT: Connections overwrite each other without proper cleanup

PRIORITY WORK ITEMS:

HIGH PRIORITY - MULTI-CLIENT SUPPORT:
1. Session-based architecture for TEE_K:
   - Replace global state (currentConn, keyShare, combinedKey) with session map
   - Create ClientSession struct containing per-client state
   - Generate unique session IDs for each WebSocket connection
   - Route messages to correct sessions based on connection mapping

2. Session-based architecture for TEE_T:
   - Replace global state (clientConn, teekConn, keyShare) with session management
   - Handle multiple TEE_K connections and multiple Client connections simultaneously
   - Maintain separate crypto contexts per session

3. Connection lifecycle management:
   - Proper session creation on WebSocket upgrade
   - Session cleanup on connection close
   - Message routing to correct session context

HIGH PRIORITY - RESOURCE LEAK FIXES:
1. Connection cleanup:
   - Add defer conn.Close() to all WebSocket handlers
   - Prevent connection overwrites without cleanup
   - Implement proper connection state management

2. Goroutine management:
   - Add context.Context to all message handler loops
   - Implement graceful goroutine cancellation
   - Set connection timeouts (30 seconds idle timeout)

3. Memory management:
   - Clear responseLengthBySeq and pendingResponses maps on session end
   - Zero out sensitive cryptographic material (keyShare, combinedKey)
   - Implement session TTL with periodic cleanup

TECHNICAL IMPLEMENTATION APPROACH:

For Multi-Client Support (Simple, Not Overcomplicating):
- Create session structs that wrap current global state
- Use sessionID (UUID) as map key for session lookup
- Route messages based on WebSocket connection to session mapping
- Keep all existing protocol logic unchanged, just make it session-aware

For Resource Leak Prevention:
- Add defer cleanup in all connection handlers
- Use context.WithTimeout for goroutine management
- Implement periodic cleanup goroutine for stale sessions
- Zero sensitive memory on session destruction

CURRENT CODEBASE STRUCTURE:
- tee_k/main.go: Service startup, WebSocket endpoint setup
- tee_k/tee_k.go: Core protocol logic, currently global state in TEEK struct
- tee_t/main.go: Service startup, dual WebSocket endpoints (/ws for clients, /teek for TEE_K)
- tee_t/tee_t.go: Core protocol logic, currently global state in TEET struct  
- client/client.go: Protocol orchestration, recently fixed completion logic
- minitls/: Custom TLS implementation for split AEAD
- shared/: Common message types and utilities

CRITICAL FILES TO MODIFY:
1. tee_k/tee_k.go: TEEK struct needs session-based refactoring
2. tee_t/tee_t.go: TEET struct needs session-based refactoring
3. Both services need session lifecycle management in WebSocket handlers

TESTING APPROACH:
- Start with single-client functionality preservation
- Add multi-client test with 2-3 concurrent clients
- Verify no session cross-contamination
- Test resource cleanup under failure scenarios
- Validate crypto material isolation between sessions

PROTOCOL FLOW (FOR REFERENCE):
1. Client connects to both TEE_K (WS) and TEE_T (WS)
2. Client sends target URL and redaction parameters to TEE_K
3. TEE_K establishes TLS connection to target website
4. Client sends redaction streams to TEE_T for verification
5. TEE_K sends HTTP request, receives TLS-encrypted response
6. TEE_K processes TLS records, sends encrypted data + tags to TEE_T
7. TEE_T verifies tags and sends back decryption streams to client
8. Client reconstructs the final HTTP response
9. Connection cleanup occurs

RECENT RACE CONDITION FIX (FOR CONTEXT):
The issue was in completion logic where two conflicting paths existed:
- handleResponseDecryptionStream() setting eofReached=true when records processed
- checkProtocolCompletion() expecting eofReached only when TCP closes
Fixed by making checkProtocolCompletion() the single source of truth with clear conditions:
- eofReached (TCP connection closed)
- recordsProcessed >= recordsSent (all split AEAD complete)
- redaction result received (if expected)

DEVELOPMENT APPROACH:
1. Implement session management without changing protocol logic
2. Add resource cleanup as you go
3. Test frequently to ensure no regression
4. Keep changes minimal and focused
5. Prefer simple solutions over complex technical fixes

The system is currently stable and working perfectly for single clients. The next step is making it multi-client capable while preventing resource leaks, using the lesson that simple architectural changes are often more effective than complex technical solutions. 